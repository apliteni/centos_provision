#!/usr/bin/env powscript


get_user_vars()
  debug 'Read vars from user input'
  print_welcome
  get_var 'ssl' 'yes_no'
  if is_yes_answer ${VARS['ssl']}
    get_var 'ssl_agree_tos' 'yes_no'
    if is_yes_answer ${VARS['ssl_agree_tos']}
      get_var 'ssl_domains'
  get_var 'license_ip'
  get_var 'license_key'
  get_var 'db_name'
  get_var 'db_user'
  get_var 'db_password'
  get_var 'admin_login'
  get_var 'admin_password'


get_var(var_name, validation_method)
  print_help $var_name
  while true
    print_prompt $var_name
    variable=$(read_stdin $var_name)
    if not empty $variable
      VARS[$var_name]=$variable
    if not empty "${VARS[$var_name]}"
      if valid "${VARS[$var_name]}" $validation_method
        debug "  $var_name=$variable"
        break
      else
        VARS[$var_name]=''
        print_error $validation_method
    else
      print_error 'empty_value'


print_welcome()
  print_translated "welcome"


print_help(var_name)
  print_translated "prompts.$var_name.help"


print_prompt(var_name)
  prompt=$(translate "prompts.$var_name")
  prompt="$(print_with_color $prompt 'bold')"
  if not empty ${VARS[$var_name]}
    prompt="$prompt [${VARS[$var_name]}]"
  echo -en "$prompt > "


# Hack: We read from FD 3 in pipe bash mode because when reading the script from a pipe,
#   FD 0 is the script, not the terminal. We checked above that FD 1 (stdout) is in fact
#   a terminal and then dup it to FD 3, thus we can input from FD 3 here.
# Source: https://install.sandstorm.io
read_stdin(var_name)
  if is_pipe_mode
    read -r -u 3 variable
  else
    read -r variable
  echo $variable


valid(value, validation_method)
  if empty $validation_method
    true
  else
    eval "validate_${validation_method}" $value


print_error(error_key)
  error=$(translate "prompt_errors.$error_key")
  print_with_color "*** ${error}" 'red'


print_translated(key)
  message=$(translate "${key}")
  if not empty $message
    echo $message


validate_yes_no(value)
  is_yes_answer $value || is_no_answer $value


is_yes_answer(answer)
  shopt -s nocasematch
  [[ $answer =~ ^(yes|y|да|д) ]]


is_no_answer(answer)
  shopt -s nocasematch
  [[ $answer =~ ^(no|n|нет|н) ]]


#prompt-yesno() {
#  while true; do
#    local VALUE=$(prompt "$@")
#
#    case $VALUE in
#      y | Y | yes | YES | Yes )
#        return 0
#        ;;
#      n | N | no | NO | No )
#        return 1
#        ;;
#    esac
#
#    echo "*** Please answer \"yes\" or \"no\"."
#  done
#}
